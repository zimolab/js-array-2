package com.github.zimolab.jsarray2.ksp.processor.generator

import com.github.zimolab.jow.compiler.asTypeName
import com.github.zimolab.jsarray2.core.IJsArray
import com.github.zimolab.jsarray2.ksp.processor.JsArrayProcessor
import com.github.zimolab.jsarray2.ksp.processor.generator.apis.JsArrayApis
import com.github.zimolab.jsarray2.ksp.processor.resolve.ResolvedClass
import com.github.zimolab.jsarray2.ksp.processor.utils.Logger
import com.github.zimolab.jsarray2.ksp.processor.utils.TypeUtils
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.squareup.kotlinpoet.*
import netscape.javascript.JSObject
import java.io.OutputStream
import java.nio.charset.Charset

@ExperimentalUnsignedTypes
class JsArrayClassGenerator(
    private val options: Map<String, String>,
    private val codeGenerator: CodeGenerator,
) {

    companion object {
        const val OPT_KEY_OUTPUT_FILE_ENCODING = "output_file_encoding"
        const val OPT_VAL_OUTPUT_FILE_ENCODING = "UTF_8"
        val CLASS_FILE_COMMENT = "" +
                "This file is automatically generated by ${JsArrayProcessor::class.simpleName}." +
                "Any changes to it may be lost.\n" +
                "DO NOT MODIFY IT MANUALLY!!!\n" +
                "Generate at ${java.time.LocalDateTime.now()}"
    }

    fun submit(resolvedClass: ResolvedClass) {
        FileGenerateTask(resolvedClass).execute()
    }

    inner class FileGenerateTask(
        private val resolvedClass: ResolvedClass
    ) {
        fun execute() {
            Logger.debug("开始为${resolvedClass.simpleName}生成代码")
            val dependencies = resolvedClass.containingFile?.let {
                Dependencies(true, it)
            } ?: Dependencies(true)
            val outputStream = codeGenerator.createNewFile(
                fileName = resolvedClass.meta.outputFilename,
                packageName = resolvedClass.packageName,
                dependencies = dependencies
            )
            write2File(createClassFileSpec(), outputStream)
            Logger.debug("文件生成完毕")
            Logger.debug("====================================")
        }

        private fun createClassFileSpec(): FileSpec {
            val imports = mapOf<String, Array<String>>()
            return FileSpec
                .builder(resolvedClass.packageName, resolvedClass.meta.outputFilename)
                .addComment(CLASS_FILE_COMMENT)
                .addType(createClassSpec()).apply {
                    imports.forEach { (packageName, names) ->
                        addImport(packageName, *names)
                    }
                }
                .build()
        }

        private fun createClassSpec(): TypeSpec {
            val className = resolvedClass.meta.outputClassName
            val packageName = resolvedClass.packageName
            val companionObjectBuilder = TypeSpec.companionObjectBuilder()
            val clazz = ClassName(packageName, className)
            val kdoc = resolvedClass.classDoc.ifEmpty { null }
            val classBuilder = TypeSpec
                .classBuilder(clazz)
                .addModifiers(KModifier.ABSTRACT)
            // 添加注释
            kdoc?.let { classBuilder.addKdoc(it) }
            // 添加超类（接口）
            classBuilder.addSuperinterface(resolvedClass.type.asTypeName())
            addJsArrayApis(classBuilder)
            return classBuilder.build()
        }

        private fun addJsArrayApis(classBuilder: TypeSpec.Builder) {
            val mapping = !(TypeUtils.isAnyType(resolvedClass.meta.jsArrayType) || TypeUtils.isNativeType(resolvedClass.meta.jsArrayType))
            val apis = JsArrayApis(resolvedClass.meta.jsArrayType)
            // 构造函数
            classBuilder.primaryConstructor(apis.primaryConstructor).addProperty(
                PropertySpec
                    .builder(IJsArray<*>::reference.name, JSObject::class)
                    .addModifiers(KModifier.OVERRIDE)
                    .initializer(IJsArray<*>::reference.name)
                    .build()
            )
            // 必要的功能函数（类型映射等）
            classBuilder.apply {
                if (mapping) {
                    addFunction(apis.mappingArgument)
                    addFunction(apis.mappingReturnValue)
                }
                addFunction(apis.newInstance)
                addFunction(apis.eval)
                addFunction(apis.invoke)
            }
            // 非迭代类函数
            classBuilder.apply {
                addProperty(apis.commonApis.length)
                addFunction(apis.commonApis.get)
                addFunction(apis.commonApis.set)
                addFunction(apis.commonApis.getAny)
                addFunction(apis.commonApis.concat)
                addFunction(apis.commonApis.join)
                addFunction(apis.commonApis.reverse)
                addFunction(apis.commonApis.pop)
                addFunction(apis.commonApis.popAny)
                addFunction(apis.commonApis.push)
                addFunction(apis.commonApis.shift)
                addFunction(apis.commonApis.shiftAny)
                addFunction(apis.commonApis.unshift)
                addFunction(apis.commonApis.slice)
                addFunction(apis.commonApis.splice)
                addFunction(apis.commonApis.fill)
                addFunction(apis.commonApis.includes)
                addFunction(apis.commonApis.includesAny)
                addFunction(apis.commonApis.indexOf)
                addFunction(apis.commonApis.indexOfAny)
                addFunction(apis.commonApis.lastIndexOf)
                addFunction(apis.commonApis.lastIndexOfAny)
                //
            }
            // 迭代相关函数
            classBuilder.apply {
                addFunction(apis.iterationApis.inject)
                addFunction(apis.iterationApis.uninject)
                addFunction(apis.iterationApis.find)
                addFunction(apis.iterationApis.findAny)
                addFunction(apis.iterationApis.findIndex)
                addFunction(apis.iterationApis.findIndexAny)
                addFunction(apis.iterationApis.forEach)
                addFunction(apis.iterationApis.forEachAny)
                addFunction(apis.iterationApis.filter)
                addFunction(apis.iterationApis.filterAny)
                addFunction(apis.iterationApis.some)
                addFunction(apis.iterationApis.someAny)
                addFunction(apis.iterationApis.every)
                addFunction(apis.iterationApis.everyAny)
                addFunction(apis.iterationApis.map)
                addFunction(apis.iterationApis.mapAny)
                addFunction(apis.iterationApis.reduce)
                addFunction(apis.iterationApis.reduceAny)
                addFunction(apis.iterationApis.reduceAny2)
                addFunction(apis.iterationApis.reduceRight)
                addFunction(apis.iterationApis.reduceRightAny)
                addFunction(apis.iterationApis.reduceRightAny2)
                addFunction(apis.iterationApis.sort)

            }
        }

        private fun write2File(fileSpec: FileSpec, outputStream: OutputStream) {
            val outputFileEncoding = try {
                if (OPT_KEY_OUTPUT_FILE_ENCODING in options) {
                    Charset.forName(options[OPT_KEY_OUTPUT_FILE_ENCODING]!!)
                } else {
                    Logger.debug("输出文件编码字符集：${resolvedClass.meta.outputFileEncoding}")
                    Charset.forName(resolvedClass.meta.outputFileEncoding)
                }
            } catch (e: Throwable) {
                Logger.warn("ksp配置项或注解中指定的编码字符集不合法，将使用缺省编码(${Charset.defaultCharset()})")
                Logger.error(e, throws = false)
                Charset.defaultCharset()
            }

            outputStream.bufferedWriter(outputFileEncoding).use {
                try {
                    fileSpec.writeTo(it)
                } catch (e: Throwable) {
                    Logger.error(e)
                    throw e
                } finally {
                    it.flush()
                    it.close()
                }
            }

        }
    }
}